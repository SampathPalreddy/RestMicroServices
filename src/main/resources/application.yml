spring:
  application:
    name: RestMicroService
  jpa:
    database-platform: org.hibernate.dialect.PostgreSQLDialect
    properties:
      hibernate:
        ddl-auto: validate
        default_schema:
          demodb
  datasource:
    url: jdbc:postgresql://127.0.0.1:5432/db_local
    password: password
    username: user
    platform: postgres
    driver-class-name: org.postgresql.Driver
  flyway:
    url: jdbc:postgresql://127.0.0.1:5432/db_local
    schemas: demodb
    password: password
    user: user
    table: FLYWAY_SCHEMA_HISTORY
    locations: classpath:/db/migration
    
    
    package com.test.POC;

import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.classic.spi.LoggingEvent;
import ch.qos.logback.core.Appender;
import org.mockito.ArgumentCaptor;

import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.atLeastOnce;
import static org.mockito.Mockito.verify;

public class VerifyLogUtil {

    public static void verifyLogFields(
            Appender<ILoggingEvent> appender,
            ArgumentCaptor<LoggingEvent> loggingEventCaptor,
            Map<String, String> fields,
            Level expectedLogLevel,
            Integer logCountIndex) {
        verify(appender, atLeastOnce()).doAppend(loggingEventCaptor.capture());
        LoggingEvent loggingEvent = loggingEventCaptor.getAllValues().get(logCountIndex);
        for (Map.Entry<String, String> entry : fields.entrySet()) {
            assertThat(loggingEvent.getFormattedMessage()).contains("\""+entry.getKey()+"\""+":\""+entry.getValue()+"\"");
        }
        assertThat(loggingEvent.getLevel()).isEqualTo(expectedLogLevel);
    }

    public static void verifyLogMessage(
            Appender<ILoggingEvent> appender,
            ArgumentCaptor<LoggingEvent> loggingEventCaptor,
            String logMessage,
            Level expectedLogLevel,
            Integer logCountIndex) {
        verify(appender, atLeastOnce()).doAppend(loggingEventCaptor.capture());
        LoggingEvent loggingEvent = loggingEventCaptor.getAllValues().get(logCountIndex);
        assertThat(loggingEvent.getFormattedMessage()).contains(logMessage);
        assertThat(loggingEvent.getLevel()).isEqualTo(expectedLogLevel);
    }
}


package com.test.POC;

import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.Logger;
import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.classic.spi.LoggingEvent;
import ch.qos.logback.core.Appender;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.Resource;
import org.springframework.messaging.MessageHeaders;
import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;


import java.util.HashMap;
import java.util.Map;
import java.util.logging.Handler;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.mockito.MockitoAnnotations.initMocks;
import static org.slf4j.LoggerFactory.getLogger;

@SpringJUnitConfig
class LoggingPOCTest {

    private LoggingPOC subject;

    @Mock
    private Appender<ILoggingEvent> mockAppender;

    @Captor
    private ArgumentCaptor<LoggingEvent> loggingEventCaptor;

    @BeforeEach
    void setUp() {
        subject = new LoggingPOC();
        Logger logger = (ch.qos.logback.classic.Logger) getLogger(LoggingPOC.class);
        logger.addAppender(mockAppender);
    }

    @Test
    void testSomePublicMethod() throws JsonProcessingException {
        subject.somePublicMethod();

        VerifyLogUtil.verifyLogMessage(mockAppender, loggingEventCaptor, "Processing complete", Level.INFO, 1);
    }

    @Test
    void testSomePublicMethodWithObject() throws JsonProcessingException {
        subject.somePublicMethod();
        Map<String, String> map =new HashMap<>();
        map.put("value", "Test1");
        map.put("data", "Data1");

        VerifyLogUtil.verifyLogFields(mockAppender, loggingEventCaptor, map, Level.INFO, 2);
    }

}


package com.test.POC;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

@Component
public class LoggingPOC {
    private static final Logger log = LoggerFactory.getLogger(LoggingPOC.class);

    public void somePublicMethod() throws JsonProcessingException {
        String data = somePrivateMethod();
        somePrivateMethodOnFields();
    }

    private String somePrivateMethod(){
        log.info("Inside somePrivateMethod");

        log.info("Processing complete");
        return "Complete";
    }

    private void somePrivateMethodOnFields() throws JsonProcessingException {

        Model model = new Model();
        model.setValue("Test1");
        model.setData("Data1");
        ObjectMapper mapper = new ObjectMapper();
        String json = mapper.writeValueAsString(model);
        log.info("Model Object" +json);
    }

    public class Model{
        private String value;
        private String data;

        public String getValue() {
            return value;
        }

        public void setValue(String value) {
            this.value = value;
        }

        public String getData() {
            return data;
        }

        public void setData(String data) {
            this.data = data;
        }
    }

}
